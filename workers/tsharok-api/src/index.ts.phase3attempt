/**
 * Tsharok API - Cloudflare Worker
 * Handles backend API requests for the Tsharok LMS
 * 
 * Rebuilt: 2025-12-21 - Phase 2
 * Clean minimal version with Phase 2: Auth + Gemma + Enrollments
 */

// ============================================
// TYPES & INTERFACES
// ============================================

export interface Env {
	DB: D1Database;
	BUCKET: R2Bucket;
	AI: any; // Cloudflare Workers AI binding for Gemma
}

// ============================================
// UTILITY FUNCTIONS
// ============================================

/**
 * Extract userId from JWT token
 */
function getUserIdFromToken(token: string): number | null {
	try {
		const parts = token.split('.');
		if (parts.length !== 3) {
			const userId = parseInt(token);
			return isNaN(userId) ? null : userId;
		}
		const payload = parts[1];
		const decoded = atob(payload.replace(/-/g, '+').replace(/_/g, '/'));
		const data = JSON.parse(decoded);
		return parseInt(data.userId || data.user_id || data.sub || data.id || '0');
	} catch (error) {
		console.error('Error decoding token:', error);
		return null;
	}
}

/**
 * Hash password using SHA-256
 */
async function hashPassword(password: string): Promise<string> {
	const encoder = new TextEncoder();
	const data = encoder.encode(password);
	const hash = await crypto.subtle.digest('SHA-256', data);
	return Array.from(new Uint8Array(hash))
		.map((b) => b.toString(16).padStart(2, '0'))
		.join('');
}

/**
 * Generate random token
 */
function generateToken(): string {
	return crypto.randomUUID() + '-' + Date.now();
}

// ============================================
// MAIN HANDLER
// ============================================

export default {
	async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
		const url = new URL(request.url);

		const corsHeaders = {
			'Access-Control-Allow-Origin': '*',
			'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
			'Access-Control-Allow-Headers': 'Content-Type, Authorization',
		};

		if (request.method === 'OPTIONS') {
			return new Response(null, { headers: corsHeaders });
		}

		try {
			// ============================================
			// AUTHENTICATION ROUTES
			// ============================================

			if (url.pathname === '/api/login' && request.method === 'POST') {
				return await handleLogin(request, env, corsHeaders);
			}

			if (url.pathname === '/api/register' && request.method === 'POST') {
				return await handleRegister(request, env, corsHeaders);
			}

			if (url.pathname === '/api/logout' && request.method === 'POST') {
				return await handleLogout(corsHeaders);
			}

			// ============================================
			// GEMMA AI CHATBOT
			// ============================================

			if (url.pathname === '/api/chatbot' && request.method === 'POST') {
				return await handleChatbot(request, env, corsHeaders);
			}

			// ============================================
			// ENROLLMENT SYSTEM
			// ============================================

			if (url.pathname === '/api/enroll' && request.method === 'POST') {
				return await handleEnroll(request, env, corsHeaders);
			}

			if (url.pathname === '/api/unenroll' && request.method === 'POST') {
				return await handleUnenroll(request, env, corsHeaders);
			}

			if (url.pathname === '/api/my-courses' && request.method === 'GET') {
				return await handleMyCourses(request, env, corsHeaders);
			}

			// ============================================
			// CONTENT & MATERIALS
			// ============================================

			if (url.pathname === '/api/view-materials' && request.method === 'GET') {
				return await handleViewMaterials(request, env, corsHeaders);
			}

			if (url.pathname === '/api/upload' && request.method === 'POST') {
				return await handleUpload(request, env, corsHeaders);
			}

			// ============================================
			// COMMENTS & RATINGS
			// ============================================

			if (url.pathname === '/api/comments' && request.method === 'GET') {
				return await handleGetComments(request, env, corsHeaders);
			}

			if (url.pathname === '/api/comments/add' && request.method === 'POST') {
				return await handleAddComment(request, env, corsHeaders);
			}

			if (url.pathname === '/api/comments/like' && request.method === 'POST') {
				return await handleCommentLike(request, env, corsHeaders);
			}

			if (url.pathname === '/api/comments/reply' && request.method === 'POST') {
				return await handleCommentReply(request, env, corsHeaders);
			}

			if (url.pathname === '/api/ratings' && request.method === 'GET') {
				return await handleGetRatings(request, env, corsHeaders);
			}

			// ============================================
			// SEARCH SYSTEM
			// ============================================

			if (url.pathname === '/api/search' && request.method === 'GET') {
				return await handleSearch(request, env, corsHeaders);
			}

			// ============================================
			// NOTIFICATIONS
			// ============================================

			if (url.pathname === '/api/notifications' && request.method === 'GET') {
				return await handleGetNotifications(request, env, corsHeaders);
			}

			if (url.pathname === '/api/notifications' && request.method === 'DELETE') {
				return await handleDeleteNotification(request, env, corsHeaders);
			}

			// ============================================
			// PROFILE & MISC
			// ============================================

			if (url.pathname === '/api/register' && request.method === 'POST') {
				return await handleRegister(request, env, corsHeaders);
			}

			if (url.pathname === '/api/profile' && request.method === 'GET') {
				return await handleProfile(request, env, corsHeaders);
			}

			// Default 404
			return new Response(
				JSON.stringify({ success: false, message: 'Not found' }),
				{ status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);

		} catch (error: any) {
			console.error('Worker error:', error);
			return new Response(
				JSON.stringify({ success: false, message: 'Internal server error', error: error.message }),
				{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}
	}
} satisfies ExportedHandler<Env>;

// ============================================
// HANDLER FUNCTIONS - PHASE 2
// ============================================

/**
 * Handle POST /api/login
 */
async function handleLogin(request: Request, env: Env, corsHeaders: Record<string, string>): Promise<Response> {
	try {
		const data = await request.json() as any;

		if (!data.identifier || !data.password) {
			return new Response(
				JSON.stringify({ success: false, message: 'Email/username and password are required' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		const identifier = data.identifier.trim();
		const password = data.password;

		const user = await env.DB.prepare(`
			SELECT 
				user_id, username, email, password_hash,
				first_name, last_name, role, major_id,
				is_active, profile_image
			FROM users
			WHERE (email = ? OR username = ?) AND is_active = 1
			LIMIT 1
		`)
			.bind(identifier, identifier)
			.first();

		if (!user) {
			return new Response(
				JSON.stringify({ success: false, message: 'Invalid credentials' }),
				{ status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		const hashedPassword = await hashPassword(password);
		if (hashedPassword !== user.password_hash) {
			return new Response(
				JSON.stringify({ success: false, message: 'Invalid credentials' }),
				{ status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		const sessionToken = generateToken();

		await env.DB.prepare(`UPDATE users SET last_login = datetime('now') WHERE user_id = ?`)
			.bind(user.user_id)
			.run();

		const userData = {
			userId: user.user_id,
			username: user.username,
			email: user.email,
			firstName: user.first_name,
			lastName: user.last_name,
			fullName: `${user.first_name} ${user.last_name}`,
			role: user.role,
			majorId: user.major_id,
			profileImage: user.profile_image,
			sessionToken: sessionToken,
		};

		const redirectUrl = user.role === 'admin' ? '/dashboard/admin.html' : '/dashboard/student.html';

		return new Response(
			JSON.stringify({
				success: true,
				message: 'Login successful! Redirecting...',
				user: userData,
				redirectUrl: redirectUrl,
			}),
			{ headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	} catch (error: any) {
		console.error('Login error:', error);
		return new Response(
			JSON.stringify({ success: false, message: 'Login failed', error: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

/**
 * Handle POST /api/register
 */
async function handleRegister(request: Request, env: Env, corsHeaders: Record<string, string>): Promise<Response> {
	try {
		const data = await request.json() as any;

		const requiredFields = ['firstName', 'lastName', 'username', 'email', 'password'];
		for (const field of requiredFields) {
			if (!data[field] || !data[field].trim()) {
				return new Response(
					JSON.stringify({ success: false, message: `${field} is required` }),
					{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
				);
			}
		}

		const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
		if (!emailRegex.test(data.email)) {
			return new Response(
				JSON.stringify({ success: false, message: 'Invalid email format' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		if (data.password.length < 6) {
			return new Response(
				JSON.stringify({ success: false, message: 'Password must be at least 6 characters' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		const existingUsername = await env.DB.prepare('SELECT user_id FROM users WHERE username = ?')
			.bind(data.username)
			.first();

		if (existingUsername) {
			return new Response(
				JSON.stringify({ success: false, message: 'Username already taken' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		const existingEmail = await env.DB.prepare('SELECT user_id FROM users WHERE email = ?')
			.bind(data.email)
			.first();

		if (existingEmail) {
			return new Response(
				JSON.stringify({ success: false, message: 'Email already registered' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		const hashedPassword = await hashPassword(data.password);

		const result = await env.DB.prepare(`
			INSERT INTO users (
				username, email, password_hash,
				first_name, last_name, role, major_id,
				phone, is_active, created_at
			) VALUES (?, ?, ?, ?, ?, ?, ?, ?, 1, datetime('now'))
		`)
			.bind(
				data.username,
				data.email,
				hashedPassword,
				data.firstName,
				data.lastName,
				'student',
				data.major || null,
				data.phone || null
			)
			.run();

		return new Response(
			JSON.stringify({
				success: true,
				message: 'Registration successful! You can now login.',
				userId: result.meta.last_row_id,
			}),
			{ headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	} catch (error: any) {
		console.error('Registration error:', error);
		return new Response(
			JSON.stringify({ success: false, message: 'Registration failed', error: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

/**
 * Handle POST /api/logout
 */
async function handleLogout(corsHeaders: Record<string, string>): Promise<Response> {
	return new Response(
		JSON.stringify({
			success: true,
			message: 'Logged out successfully',
		}),
		{ headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
	);
}

/**
 * Handle POST /api/chatbot - AI chatbot with Gemma
 */
async function handleChatbot(
	request: Request,
	env: Env,
	corsHeaders: Record<string, string>
): Promise<Response> {
	try {
		const { message, userId, conversationHistory = [] } = await request.json() as any;
		console.log('Chatbot request:', { message, userId });

		let userContext = '';

		if (userId) {
			console.log('User ID provided:', userId);

			const courses = await env.DB.prepare(`
				SELECT c.title, c.course_id
				FROM enrollments e
				JOIN courses c ON e.course_id = c.course_id
				WHERE e.student_id = ? AND e.status = 'active'
				LIMIT 5
			`).bind(userId).all();

			console.log('Courses query result:', courses.results);

			if (courses.results && courses.results.length > 0) {
				// Format as numbered list for clarity
				const courseListItems = courses.results
					.map((c: any, index: number) => `${index + 1}. ${c.title}`)
					.join('\n');

				userContext = `THE STUDENT IS CURRENTLY ENROLLED IN THESE EXACT COURSES:
${courseListItems}

CRITICAL: When asked about courses, you MUST list ONLY the courses shown above. 
Do NOT make up example courses like "English 101" or "Mathematics 120".
Use the EXACT course names from the list above.
`;
				console.log('User context set:', userContext);
			} else {
				console.log('No courses found for user:', userId);
			}
		}

		const systemPrompt = `You are Tsharok Assistant, an intelligent AI helper for students at Umm Al-Qura University.

Your role:
- Help students find courses and materials
- Answer questions about assignments and content
- Guide them through the platform
- Provide study tips and academic advice
- Respond in the SAME language the user uses (Arabic or English)

${userContext}
IMPORTANT INSTRUCTIONS:
- When asked about enrolled courses, YOU MUST list them from the information provided above
- This course enrollment information is meant to be shared with the student - it is NOT private
- If the student asks "what courses am I taking" or similar, directly tell them their enrolled courses
- Be friendly, helpful, and concise (2-3 sentences max)
- If you don't know something, suggest they check with their instructor
- Keep responses educational and professional`;

		const messages = [
			{ role: 'system', content: systemPrompt },
			...conversationHistory.slice(-10),
			{ role: 'user', content: message }
		];

		console.log('Calling Llama 3 AI...');

		const response = await env.AI.run('@cf/meta/llama-3-8b-instruct', {
			messages: messages,
			max_tokens: 512,
			temperature: 0.7
		}) as any;

		console.log('Llama 3 response:', response);

		const aiReply = response.response || response.text || 'Sorry, I could not generate a response.';

		return new Response(
			JSON.stringify({
				success: true,
				reply: aiReply,
				model: 'llama-3-8b-instruct',
				timestamp: new Date().toISOString()
			}),
			{
				status: 200,
				headers: { ...corsHeaders, 'Content-Type': 'application/json' }
			}
		);

	} catch (error: any) {
		console.error('Chatbot error:', error);

		const fallbackResponse = 'I apologize, but I encountered an error. Please try asking your question again.';

		return new Response(
			JSON.stringify({
				success: true,
				reply: fallbackResponse,
				error: error.message,
				fallback: true
			}),
			{
				status: 200,
				headers: { ...corsHeaders, 'Content-Type': 'application/json' }
			}
		);
	}
}

/**
 * Handle POST /api/enroll - Enroll student in course
 */
async function handleEnroll(
	request: Request,
	env: Env,
	corsHeaders: Record<string, string>
): Promise<Response> {
	try {
		const { courseId, userId } = await request.json() as any;

		if (!courseId || !userId) {
			return new Response(
				JSON.stringify({ success: false, message: 'Missing courseId or userId' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		const existing = await env.DB.prepare(`
			SELECT enrollment_id FROM enrollments 
			WHERE student_id = ? AND course_id = ?
		`).bind(userId, courseId).first();

		if (existing) {
			await env.DB.prepare(`
				UPDATE enrollments 
				SET status = 'active', enrollment_date = CURRENT_TIMESTAMP
				WHERE student_id = ? AND course_id = ?
			`).bind(userId, courseId).run();
		} else {
			await env.DB.prepare(`
				INSERT INTO enrollments (student_id, course_id, status, enrollment_date, progress_percent)
				VALUES (?, ?, 'active', CURRENT_TIMESTAMP, 0)
			`).bind(userId, courseId).run();
		}

		return new Response(
			JSON.stringify({ success: true, message: 'Enrolled successfully' }),
			{ status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);

	} catch (error: any) {
		console.error('Enrollment error:', error);
		return new Response(
			JSON.stringify({ success: false, message: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

/**
 * Handle POST /api/unenroll - Unenroll student from course
 */
async function handleUnenroll(
	request: Request,
	env: Env,
	corsHeaders: Record<string, string>
): Promise<Response> {
	try {
		const { courseId, userId } = await request.json() as any;

		if (!courseId || !userId) {
			return new Response(
				JSON.stringify({ success: false, message: 'Missing courseId or userId' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		await env.DB.prepare(`
			UPDATE enrollments 
			SET status = 'dropped'
			WHERE student_id = ? AND course_id = ?
		`).bind(userId, courseId).run();

		return new Response(
			JSON.stringify({ success: true, message: 'Unenrolled successfully' }),
			{ status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);

	} catch (error: any) {
		console.error('Unenrollment error:', error);
		return new Response(
			JSON.stringify({ success: false, message: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

/**
 * Handle GET /api/my-courses - Get student's enrolled courses
 */
async function handleMyCourses(
	request: Request,
	env: Env,
	corsHeaders: Record<string, string>
): Promise<Response> {
	try {
		const url = new URL(request.url);
		const userId = url.searchParams.get('userId');

		if (!userId) {
			return new Response(
				JSON.stringify({ success: false, message: 'Missing userId parameter' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		const result = await env.DB.prepare(`
			SELECT 
				c.course_id as courseId,
				c.title,
				c.description,
				c.level,
				e.enrollment_date
			FROM enrollments e
			JOIN courses c ON e.course_id = c.course_id
			WHERE e.student_id = ? AND e.status = 'active'
			ORDER BY e.enrollment_date DESC
		`).bind(userId).all();

		return new Response(
			JSON.stringify({
				success: true,
				data: { courses: result.results || [] }
			}),
			{ status: 200, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);

	} catch (error: any) {
		console.error('My courses error:', error);
		return new Response(
			JSON.stringify({ success: false, message: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

// ============================================
// HANDLER FUNCTIONS - PHASE 3
// ============================================

/**
 * Handle GET /api/view-materials?course_id=X
 */
async function handleViewMaterials(request: Request, env: Env, corsHeaders: Record<string, string>): Promise<Response> {
const url = new URL(request.url);
const courseId = url.searchParams.get('course_id');

if (!courseId) {
return new Response(
JSON.stringify({ success: false, message: 'course_id parameter is required' }),
{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
);
}

try {
const result = await env.DB.prepare(`
SELECT 
c.id, c.title, c.type, c.file_url, c.upload_date,
c.description, c.file_size, c.mime_type, c.file_extension,
c.is_approved, c.uploader_id,
u.first_name || ' ' || u.last_name as uploader_name,
COALESCE(AVG(r.score), 0) as avg_rating,
COUNT(r.id) as rating_count
FROM content c
LEFT JOIN users u ON c.uploader_id = u.user_id
LEFT JOIN ratings r ON c.id = r.content_id
WHERE c.course_id = ? AND c.is_approved = 1
GROUP BY c.id
ORDER BY c.upload_date DESC
`).bind(courseId).all();

const materials = (result.results || []).map((material: any) => ({
id: material.id,
title: material.title,
type: material.type,
description: material.description,
file_url: material.file_url,
file_size: material.file_size,
mime_type: material.mime_type,
file_extension: material.file_extension,
is_approved: Boolean(material.is_approved),
upload_date: material.upload_date,
uploader: {
id: material.uploader_id,
name: material.uploader_name || 'Student',
},
statistics: {
avg_rating: material.avg_rating ? parseFloat(parseFloat(String(material.avg_rating)).toFixed(1)) : 0.0,
rating_count: Number(material.rating_count) || 0,
},
}));

return new Response(JSON.stringify({
success: true,
message: 'Materials fetched successfully',
data: { materials, total_count: materials.length },
}), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } });

} catch (error: any) {
console.error('Database error:', error);
return new Response(
JSON.stringify({ success: false, message: 'Failed to fetch materials', error: error.message }),
{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
);
}
}

// ============================================
// PHASE 3 HANDLER FUNCTIONS
// ============================================

/**
 * Handle GET /api/view-materials?course_id=X
 */
async function handleViewMaterials(url: URL, env: Env, corsHeaders: Record<string, string>): Promise<Response> {
	const courseId = url.searchParams.get('course_id');

	if (!courseId) {
		return new Response(
			JSON.stringify({ success: false, message: 'course_id parameter is required' }),
			{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}

	try {
		// Query D1 database
		const result = await env.DB.prepare(`
		SELECT 
			c.id, c.title, c.type, c.file_url, c.upload_date,
			c.description, c.file_size, c.mime_type, c.file_extension,
			c.is_approved, c.uploader_id,
			u.first_name || ' ' || u.last_name as uploader_name, u.email as uploader_email,
			COALESCE(AVG(r.score), 0) as avg_rating,
			COUNT(r.id) as rating_count
		FROM content c
		LEFT JOIN users u ON c.uploader_id = u.user_id
		LEFT JOIN ratings r ON c.id = r.content_id
		WHERE c.course_id = ? AND c.is_approved = 1
		GROUP BY c.id
		ORDER BY c.upload_date DESC
	`)
			.bind(courseId)
			.all();

		// Format response
		const materials = result.results.map((material: any) => ({
			id: material.id,
			title: material.title,
			type: material.type,
			description: material.description,
			file_url: material.file_url,
			file_size: material.file_size,
			mime_type: material.mime_type,
			file_extension: material.file_extension,
			is_approved: Boolean(material.is_approved),
			upload_date: material.upload_date,
			uploader: {
				id: material.uploader_id,
				name: material.uploader_name || 'Student',
				email: material.uploader_email,
			},
			statistics: {
				avg_rating: material.avg_rating ? parseFloat(parseFloat(String(material.avg_rating)).toFixed(1)) : 0.0,
				rating_count: Number(material.rating_count) || 0,
			},
		}));

		const response = {
			success: true,
			message: 'Materials fetched successfully',
			timestamp: new Date().toISOString(),
			data: {
				materials: materials,
				total_count: materials.length,
				returned_count: materials.length,
			},
		};

		return new Response(JSON.stringify(response), {
			headers: { ...corsHeaders, 'Content-Type': 'application/json' },
		});
	} catch (error: any) {
		console.error('Database error:', error);
		return new Response(
			JSON.stringify({
				success: false,
				message: 'Failed to fetch materials',
				error: error.message,
			}),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

/**
 * Handle POST /api/upload
 * Upload file to R2 and save metadata to D1
 */
async function handleUpload(request: Request, env: Env, corsHeaders: Record<string, string>): Promise<Response> {
	try {
		const formData = await request.formData();

		// Get form fields
		const file = formData.get('file') as File;
		const title = formData.get('title') as string;
		const courseId = formData.get('courseId') as string;
		const userId = formData.get('userId') as string;
		const description = formData.get('description') as string || '';
		const type = formData.get('type') as string || 'document';

		// Validate
		if (!file || !title || !courseId || !userId) {
			return new Response(
				JSON.stringify({ success: false, message: 'Missing required fields' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		// Generate unique filename
		const timestamp = Date.now();
		const extension = file.name.split('.').pop();
		const r2Key = `uploads/${courseId}/${timestamp}-${file.name}`;

		// Upload to R2
		await env.BUCKET.put(r2Key, file.stream(), {
			httpMetadata: {
				contentType: file.type,
			},
		});

		// Get public URL
		const fileUrl = `https://pub-cd42bce9da7242b69d703b8bf1e9e4b6.r2.dev/${r2Key}`;

		// Save to D1 database
		const result = await env.DB.prepare(`
			INSERT INTO content (
				course_id, uploader_id, title, description,
				type, file_url, file_key, file_size, mime_type, file_extension,
				is_approved, upload_date
			) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 1, datetime('now'))
		`)
			.bind(
				courseId,
				userId,
				title,
				description,
				type,
				fileUrl,
				r2Key,
				file.size,
				file.type,
				extension
			)
			.run();

		// Create notifications for enrolled students
		await createContentNotifications(
			parseInt(courseId),
			result.meta.last_row_id as number,
			title,
			parseInt(userId),
			env
		);

		return new Response(
			JSON.stringify({
				success: true,
				message: 'File uploaded successfully',
				data: {
					id: result.meta.last_row_id,
					title: title,
					fileUrl: fileUrl,
					r2Key: r2Key,
				},
			}),
			{ headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	} catch (error: any) {
		console.error('Upload error:', error);
		return new Response(
			JSON.stringify({ success: false, message: 'Upload failed', error: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

/**
 * Handle GET /api/comments
 * Get reviews/comments for a content item with pagination
 */
async function handleGetComments(url: URL, env: Env, corsHeaders: Record<string, string>): Promise<Response> {
	const contentId = url.searchParams.get('contentId');
	const page = parseInt(url.searchParams.get('page') || '1');
	const limit = parseInt(url.searchParams.get('limit') || '10');
	const userIdParam = url.searchParams.get('userId') || '0';

	// Decode JWT if it's a token, otherwise use as-is
	const userId = getUserIdFromToken(userIdParam) || 0;

	if (!contentId) {
		return new Response(
			JSON.stringify({ success: false, message: 'contentId parameter is required' }),
			{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}

	try {
		const offset = (page - 1) * limit;

		// Get comments with ratings and like info
		const query = `
			SELECT 
				c.id,
				c.content,
				c.created_at,
				c.updated_at,
				u.user_id,
				u.username,
				u.first_name || ' ' || u.last_name as user_name,
				u.profile_image as user_avatar,
				r.score,
				CASE WHEN c.user_id = ? THEN 1 ELSE 0 END as is_own_comment,
				(SELECT COUNT(*) FROM comment_likes WHERE comment_id = c.id) as likes,
				CASE WHEN EXISTS(SELECT 1 FROM comment_likes WHERE comment_id = c.id AND user_id = ?) THEN 1 ELSE 0 END as likedByMe
			FROM comments c
			INNER JOIN users u ON c.user_id = u.user_id
			LEFT JOIN ratings r ON c.user_id = r.user_id AND c.content_id = r.content_id
			WHERE c.content_id = ?
			ORDER BY 
				CASE WHEN EXISTS(SELECT 1 FROM comment_likes WHERE comment_id = c.id AND user_id = ?) THEN 0 ELSE 1 END,
				c.created_at DESC
			LIMIT ? OFFSET ?
		`;

		const params = [userId, userId, contentId, userId, limit + 1, offset];
		const result = await env.DB.prepare(query).bind(...params).all();

		const comments = result.results as any[];
		const hasMore = comments.length > limit;

		if (hasMore) {
			comments.pop();
		}

		// Fetch replies for each comment
		for (const comment of comments) {
			const repliesResult = await env.DB.prepare(
				`SELECT 
					cr.id,
					cr.content as text,
					cr.created_at,
					u.first_name || ' ' || u.last_name as author,
					u.username
				FROM comment_replies cr
				JOIN users u ON cr.user_id = u.user_id
				WHERE cr.comment_id = ?
				ORDER BY cr.created_at ASC`
			)
				.bind(comment.id)
				.all();

			comment.replies = repliesResult.results || [];
		}

		// Format comments
		const formattedComments = comments.map((comment) => ({
			id: comment.id,
			userName: comment.user_name,
			username: comment.username,
			userAvatar: comment.user_avatar,
			score: comment.score || 0,
			content: comment.content,
			createdAt: comment.created_at,
			updatedAt: comment.updated_at,
			isOwnComment: Boolean(comment.is_own_comment),
			likes: comment.likes || 0,
			likedByMe: Boolean(comment.likedByMe),
			replies: (comment.replies || []).map((reply: any) => ({
				id: reply.id,
				text: reply.text,
				author: reply.author,
				username: reply.username,
				createdAt: reply.created_at,
			})),
		}));

		return new Response(
			JSON.stringify({
				success: true,
				message: 'Comments retrieved successfully',
				data: {
					comments: formattedComments,
					hasMore: hasMore,
					page: page,
					limit: limit,
				},
			}),
			{ headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	} catch (error: any) {
		console.error('Get comments error:', error);
		return new Response(
			JSON.stringify({ success: false, message: 'Failed to retrieve comments', error: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

/**
 * Handle GET /api/ratings
 * Get average rating for content
 */
async function handleGetRatings(url: URL, env: Env, corsHeaders: Record<string, string>): Promise<Response> {
	const contentId = url.searchParams.get('contentId');

	if (!contentId) {
		return new Response(
			JSON.stringify({ success: false, message: 'contentId parameter is required' }),
			{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}

	try {
		// Get average rating and count
		const result = await env.DB.prepare(
			`SELECT 
				AVG(score) as averageRating,
				COUNT(*) as totalRatings
			FROM ratings
			WHERE content_id = ?`
		)
			.bind(contentId)
			.first();

		const averageRating = result ? (result.averageRating as number) || 0 : 0;
		const totalRatings = result ? (result.totalRatings as number) || 0 : 0;

		return new Response(
			JSON.stringify({
				success: true,
				message: 'Ratings retrieved successfully',
				data: {
					averageRating: averageRating,
					totalRatings: totalRatings,
				},
			}),
			{ headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	} catch (error: any) {
		console.error('Get ratings error:', error);
		return new Response(
			JSON.stringify({ success: false, message: 'Failed to retrieve ratings', error: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

/**
 * Handle POST /api/comments/add
 * Add a new rating and comment for content
 */
async function handleAddComment(request: Request, env: Env, corsHeaders: Record<string, string>): Promise<Response> {
	try {
		const data = (await request.json()) as any;

		// Validate required fields
		if (!data.userId || !data.contentId || !data.score || !data.content) {
			return new Response(
				JSON.stringify({ success: false, message: 'Missing required fields: userId, contentId, score, content' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		const userId = parseInt(data.userId);
		const contentId = parseInt(data.contentId);
		const score = parseFloat(data.score);
		const content = data.content.trim();

		// Validate score
		if (score < 0 || score > 5) {
			return new Response(
				JSON.stringify({ success: false, message: 'Score must be between 0 and 5' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		// Validate content length
		if (content.length < 1 || content.length > 5000) {
			return new Response(
				JSON.stringify({ success: false, message: 'Comment must be between 1 and 5000 characters' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		// Check if user has already rated this content
		const existingRating = await env.DB.prepare(`SELECT id FROM ratings WHERE user_id = ? AND content_id = ?`)
			.bind(userId, contentId)
			.first();

		if (existingRating) {
			// Update existing rating
			await env.DB.prepare(`UPDATE ratings SET score = ?, updated_at = datetime('now') WHERE user_id = ? AND content_id = ?`)
				.bind(score, userId, contentId)
				.run();
		} else {
			// Insert new rating
			await env.DB.prepare(`INSERT INTO ratings (user_id, content_id, score, created_at) VALUES (?, ?, ?, datetime('now'))`)
				.bind(userId, contentId, score)
				.run();
		}

		// Insert comment
		const commentResult = await env.DB.prepare(
			`INSERT INTO comments (user_id, content_id, content, created_at) VALUES (?, ?, ?, datetime('now'))`
		)
			.bind(userId, contentId, content)
			.run();

		const commentId = commentResult.meta.last_row_id;

		return new Response(
			JSON.stringify({
				success: true,
				message: 'Rating and comment submitted successfully',
				data: {
					commentId: commentId,
				},
			}),
			{ headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	} catch (error: any) {
		console.error('Add comment error:', error);
		return new Response(
			JSON.stringify({ success: false, message: 'Failed to submit rating and comment', error: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

/**
 * Handle POST /api/comments/like
 * Toggle like on a comment
 */
async function handleCommentLike(request: Request, env: Env, corsHeaders: Record<string, string>): Promise<Response> {
	const authHeader = request.headers.get('Authorization');
	if (!authHeader || !authHeader.startsWith('Bearer ')) {
		return new Response(
			JSON.stringify({ success: false, message: 'Authentication required' }),
			{ status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}

	try {
		const data = await request.json() as any;
		const commentId = data.commentId;
		const token = authHeader.substring(7);
		const userId = getUserIdFromToken(token);

		if (!userId) {
			return new Response(
				JSON.stringify({ success: false, message: 'Invalid token' }),
				{ status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		if (!commentId) {
			return new Response(
				JSON.stringify({ success: false, message: 'commentId is required' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		// Check if comment exists
		const commentExists = await env.DB.prepare('SELECT id FROM comments WHERE id = ?')
			.bind(commentId)
			.first();

		if (!commentExists) {
			return new Response(
				JSON.stringify({ success: false, message: 'Comment not found' }),
				{ status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		// Check if user already liked
		const existingLike = await env.DB.prepare(
			'SELECT id FROM comment_likes WHERE comment_id = ? AND user_id = ?'
		)
			.bind(commentId, userId)
			.first();

		let liked = false;
		if (existingLike) {
			// Unlike - remove like
			await env.DB.prepare('DELETE FROM comment_likes WHERE comment_id = ? AND user_id = ?')
				.bind(commentId, userId)
				.run();
			liked = false;
		} else {
			// Like - add like
			await env.DB.prepare(
				"INSERT INTO comment_likes (comment_id, user_id, created_at) VALUES (?, ?, datetime('now'))"
			)
				.bind(commentId, userId)
				.run();
			liked = true;
		}

		// Get updated like count
		const likeCountResult = await env.DB.prepare(
			'SELECT COUNT(*) as count FROM comment_likes WHERE comment_id = ?'
		)
			.bind(commentId)
			.first();

		const likeCount = (likeCountResult as any).count || 0;

		return new Response(
			JSON.stringify({
				success: true,
				liked: liked,
				likes: likeCount,
				message: liked ? 'Comment liked' : 'Comment unliked',
			}),
			{ headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	} catch (error: any) {
		console.error('Comment like error:', error);
		return new Response(
			JSON.stringify({ success: false, message: 'Failed to toggle like', error: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

/**
 * Handle POST /api/comments/reply
 * Add a reply to a comment
 */
async function handleCommentReply(request: Request, env: Env, corsHeaders: Record<string, string>): Promise<Response> {
	const authHeader = request.headers.get('Authorization');
	if (!authHeader || !authHeader.startsWith('Bearer ')) {
		return new Response(
			JSON.stringify({ success: false, message: 'Authentication required' }),
			{ status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}

	try {
		const data = await request.json() as any;
		const commentId = data.commentId;
		const text = data.text?.trim();
		const token = authHeader.substring(7);
		const userId = getUserIdFromToken(token);

		if (!userId) {
			return new Response(
				JSON.stringify({ success: false, message: 'Invalid token' }),
				{ status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		if (!commentId) {
			return new Response(
				JSON.stringify({ success: false, message: 'commentId is required' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		if (!text) {
			return new Response(
				JSON.stringify({ success: false, message: 'Reply text is required' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		if (text.length > 1000) {
			return new Response(
				JSON.stringify({ success: false, message: 'Reply text is too long (max 1000 characters)' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		// Check if comment exists
		const commentExists = await env.DB.prepare('SELECT id FROM comments WHERE id = ?')
			.bind(commentId)
			.first();

		if (!commentExists) {
			return new Response(
				JSON.stringify({ success: false, message: 'Comment not found' }),
				{ status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		// Insert reply
		const replyResult = await env.DB.prepare(
			`INSERT INTO comment_replies (comment_id, user_id, content, created_at, updated_at) 
			 VALUES (?, ?, ?, datetime('now'), datetime('now'))`
		)
			.bind(commentId, userId, text)
			.run();

		const replyId = replyResult.meta.last_row_id;

		// Get reply with user info
		const reply = await env.DB.prepare(
			`SELECT 
				cr.id,
				cr.comment_id,
				cr.user_id,
				cr.content as text,
				cr.created_at,
				u.first_name || ' ' || u.last_name as author,
				u.username
			 FROM comment_replies cr
			 JOIN users u ON cr.user_id = u.user_id
			 WHERE cr.id = ?`
		)
			.bind(replyId)
			.first();

		return new Response(
			JSON.stringify({
				success: true,
				reply: reply,
				message: 'Reply added successfully',
			}),
			{ headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	} catch (error: any) {
		console.error('Comment reply error:', error);
		return new Response(
			JSON.stringify({ success: false, message: 'Failed to add reply', error: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

/**
 * Handle GET /api/search
 * Search courses with filters, sorting, and pagination
 */
async function handleSearch(url: URL, env: Env, corsHeaders: Record<string, string>): Promise<Response> {
	const searchQuery = url.searchParams.get('q')?.trim() || '';
	const category = url.searchParams.get('category')?.trim() || '';
	const level = url.searchParams.get('level')?.trim() || '';
	const minRating = parseFloat(url.searchParams.get('minRating') || '0');
	const sortBy = url.searchParams.get('sortBy') || 'relevance';
	const page = Math.max(1, parseInt(url.searchParams.get('page') || '1'));
	const limit = Math.min(50, Math.max(1, parseInt(url.searchParams.get('limit') || '12')));
	const offset = (page - 1) * limit;

	try {
		// Build WHERE conditions
		const whereConditions = ['c.is_published = 1'];
		const params: any[] = [];

		// Search relevance calculation
		let relevanceScore = '0 as relevance';
		if (searchQuery) {
			relevanceScore = `
				CASE
					WHEN c.title = ? THEN 3
					WHEN c.title LIKE ? THEN 2
					WHEN c.description LIKE ? THEN 1
					ELSE 0
				END as relevance
			`;
			params.push(searchQuery, searchQuery + '%', '%' + searchQuery + '%');

			// Add search filter
			whereConditions.push('(c.title LIKE ? OR c.description LIKE ?)');
			params.push('%' + searchQuery + '%', '%' + searchQuery + '%');
		}

		// Category filter
		if (category && category !== 'all') {
			whereConditions.push('c.category = ?');
			params.push(category);
		}

		// Level filter
		if (level && level !== 'all') {
			whereConditions.push('c.level = ?');
			params.push(level);
		}

		const whereClause = whereConditions.join(' AND ');

		// Count total results
		const countQuery = `
			SELECT COUNT(DISTINCT c.course_id) as total
			FROM courses c
			WHERE ${whereClause}
		`;
		const countResult = await env.DB.prepare(countQuery).bind(...params).first();
		const totalResults = countResult?.total || 0;

		// Build main query
		const query = `
			SELECT 
				c.course_id,
				c.title,
				c.description,
				c.category,
				c.level,
				c.duration_weeks,
				c.thumbnail,
				c.start_date,
				c.end_date,
				c.semester,
				c.created_at,
				${relevanceScore},
				COUNT(DISTINCT e.enrollment_id) as enrollment_count,
				COALESCE(AVG(r.score), 0) as average_rating,
				COUNT(DISTINCT r.id) as rating_count
			FROM courses c
			LEFT JOIN enrollments e ON c.course_id = e.course_id AND e.status = 'active'
			LEFT JOIN ratings r ON c.course_id = r.content_id
			WHERE ${whereClause}
			GROUP BY c.course_id
			HAVING (? = 0 OR average_rating >= ?)
			ORDER BY ${getSortOrder(sortBy, !!searchQuery)}
			LIMIT ? OFFSET ?
		`;

		const queryParams = [...params, minRating, minRating, limit + 1, offset];
		const result = await env.DB.prepare(query).bind(...queryParams).all();

		const courses = result.results as any[];
		const hasMore = courses.length > limit;
		if (hasMore) courses.pop();

		// Format courses
		const formattedCourses = courses.map((course) => ({
			courseId: course.course_id,
			title: course.title,
			description: truncateText(course.description || '', 150),
			category: course.category || 'General',
			level: capitalize(course.level),
			duration: course.duration_weeks ? `${course.duration_weeks} weeks` : 'N/A',
			thumbnail: course.thumbnail || '/assets/images/default-course.jpg',
			enrollmentCount: course.enrollment_count || 0,
			averageRating: Math.round(course.average_rating * 10) / 10,
			ratingCount: course.rating_count || 0,
			startDate: course.start_date,
			endDate: course.end_date,
			semester: course.semester,
			relevance: course.relevance || 0,
			createdAt: course.created_at,
		}));

		const totalPages = Math.ceil(totalResults / limit);

		return new Response(
			JSON.stringify({
				success: true,
				message: 'Search completed successfully',
				data: {
					courses: formattedCourses,
					pagination: {
						currentPage: page,
						totalPages: totalPages,
						totalResults: totalResults,
						hasMore: hasMore,
						limit: limit,
					},
					filters: {
						searchQuery: searchQuery,
						category: category,
						level: level,
						minRating: minRating,
						sortBy: sortBy,
					},
				},
			}),
			{ headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	} catch (error: any) {
		console.error('Search error:', error);
		return new Response(
			JSON.stringify({ success: false, message: 'Failed to perform search', error: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

/**
 * Handle GET /api/notifications - Get notifications for a user
 */
async function handleGetNotifications(url: URL, request: Request, env: Env, corsHeaders: Record<string, string>): Promise<Response> {
	try {
		const authHeader = request.headers.get('Authorization');
		let userId: number | null = null;

		if (authHeader) {
			const token = authHeader.replace('Bearer ', '');
			userId = getUserIdFromToken(token);
		}

		if (!userId) {
			userId = parseInt(url.searchParams.get('userId') || '0');
		}

		if (!userId) {
			return new Response(
				JSON.stringify({ success: false, message: 'userId is required' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		// Get limit from query parameter (default 10, max 50)
		const limit = Math.min(50, Math.max(1, parseInt(url.searchParams.get('limit') || '10')));

		const result = await env.DB.prepare(`
			SELECT 
				n.id, n.user_id, n.course_id, n.content_id,
				n.type, n.title, n.message, n.is_read, n.created_at,
				c.title as course_name,
				co.title as content_title
			FROM notifications n
			LEFT JOIN courses c ON n.course_id = c.course_id
			LEFT JOIN content co ON n.content_id = co.id
			WHERE n.user_id = ?
			ORDER BY n.created_at DESC
			LIMIT ?
		`).bind(userId, limit).all();

		const unreadResult = await env.DB.prepare(`
			SELECT COUNT(*) as count
			FROM notifications
			WHERE user_id = ? AND is_read = 0
		`).bind(userId).first();

		const notifications = result.results.map((notif: any) => ({
			id: notif.id,
			userId: notif.user_id,
			courseId: notif.course_id,
			contentId: notif.content_id,
			type: notif.type,
			title: notif.title,
			message: notif.message,
			isRead: Boolean(notif.is_read),
			createdAt: notif.created_at,
			courseName: notif.course_name,
			contentTitle: notif.content_title,
		}));

		return new Response(
			JSON.stringify({
				success: true,
				notifications: notifications,
				unreadCount: unreadResult?.count || 0,
			}),
			{ headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	} catch (error: any) {
		console.error('Get notifications error:', error);
		return new Response(
			JSON.stringify({ success: false, message: 'Failed to get notifications', error: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

/**
 * Handle DELETE /api/notifications - Delete a notification permanently
 */
async function handleDeleteNotification(
	request: Request,
	env: Env,
	corsHeaders: Record<string, string>
): Promise<Response> {
	try {
		const url = new URL(request.url);
		const notificationId = parseInt(url.searchParams.get('notificationId') || '0');

		if (!notificationId) {
			return new Response(
				JSON.stringify({ success: false, message: 'notificationId is required' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		// Delete the notification from database
		await env.DB.prepare(`
			DELETE FROM notifications
			WHERE id = ?
		`).bind(notificationId).run();

		console.log(`Deleted notification ${notificationId}`);

		return new Response(
			JSON.stringify({
				success: true,
				message: 'Notification deleted successfully'
			}),
			{ headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	} catch (error: any) {
		console.error('Delete notification error:', error);
		return new Response(
			JSON.stringify({ success: false, message: 'Failed to delete notification', error: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

 * Handle POST /api/notifications/mark-read
 */
async function handleMarkNotificationRead(request: Request, env: Env, corsHeaders: Record<string, string>): Promise<Response> {
	try {
		const data = await request.json() as any;

		if (!data.notificationId) {
			return new Response(
				JSON.stringify({ success: false, message: 'notificationId is required' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		await env.DB.prepare(`UPDATE notifications SET is_read = 1 WHERE id = ?`)
			.bind(data.notificationId)
			.run();

		return new Response(
			JSON.stringify({ success: true, message: 'Notification marked as read' }),
			{ headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	} catch (error: any) {
		console.error('Mark notification read error:', error);
		return new Response(
			JSON.stringify({ success: false, message: 'Failed to mark notification as read', error: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

/**
 * Handle POST /api/notifications/mark-all-read
 */
async function handleMarkAllNotificationsRead(request: Request, env: Env, corsHeaders: Record<string, string>): Promise<Response> {
	try {
		const data = await request.json() as any;
		let userId = data.userId;

		if (!userId) {
			const authHeader = request.headers.get('Authorization');
			if (authHeader) {
				const token = authHeader.replace('Bearer ', '');
				userId = getUserIdFromToken(token);
			}
		}

		if (!userId) {
			return new Response(
				JSON.stringify({ success: false, message: 'userId is required' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		await env.DB.prepare(`UPDATE notifications SET is_read = 1 WHERE user_id = ? AND is_read = 0`)
			.bind(userId)
			.run();

		return new Response(
			JSON.stringify({ success: true, message: 'All notifications marked as read' }),
			{ headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	} catch (error: any) {
		console.error('Mark all notifications read error:', error);
		return new Response(
			JSON.stringify({ success: false, message: 'Failed to mark all notifications as read', error: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

/**
 * Create notifications for enrolled students when new content is uploaded
 */
async function createContentNotifications(
	courseId: number,
	contentId: number,
	contentTitle: string,
	uploaderId: number,
	env: Env
): Promise<void> {
	try {
		console.log('=== CREATE CONTENT NOTIFICATIONS ===');
		console.log('Course ID:', courseId);
		console.log('Content ID:', contentId);
		console.log('Content Title:', contentTitle);
		console.log('Uploader ID:', uploaderId);

		// Fetch course name
		const course = await env.DB.prepare(`
			SELECT title FROM courses WHERE course_id = ?
		`).bind(courseId).first();

		const courseName = course?.title || 'your course';
		console.log('Course Name:', courseName);

		const enrolled = await env.DB.prepare(`
			SELECT student_id
			FROM enrollments
			WHERE course_id = ? AND student_id != ? AND status = 'active'
		`).bind(courseId, uploaderId).all();

		console.log('Enrolled students found:', enrolled.results?.length || 0);
		console.log('Enrolled students:', enrolled.results);

		if (!enrolled.results || enrolled.results.length === 0) {
			console.log('No students to notify for course', courseId);
			return;
		}

		for (const student of enrolled.results as any[]) {
			console.log('Creating notification for student:', student.student_id);
			await env.DB.prepare(`
				INSERT INTO notifications (user_id, course_id, content_id, type, title, message)
				VALUES (?, ?, ?, 'content_upload', 'New content uploaded', ?)
			`).bind(
				student.student_id,
				courseId,
				contentId,
				`${contentTitle} was uploaded to ${courseName}`
			).run();
		}

		console.log(`Created ${enrolled.results.length} notifications for course ${courseId}`);
	} catch (error: any) {
		console.error('Error creating content notifications:', error);
	}
}


/**
 * Handle POST /api/enroll - Enroll student in course
 */
async function handleEnroll(
	request: Request,
	env: Env,
	corsHeaders: Record<string, string>
): Promise<Response> {
	try {
		const { courseId, userId } = await request.json();

		if (!courseId || !userId) {
			return new Response(
				JSON.stringify({ success: false, message: 'Missing courseId or userId' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		// Check if already enrolled
		const existing = await env.DB.prepare(`
			SELECT enrollment_id FROM enrollments 
			WHERE student_id = ? AND course_id = ?
		`).bind(userId, courseId).first();

		if (existing) {
			// Update to active if it was dropped
			await env.DB.prepare(`
				UPDATE enrollments 
				SET status = 'active', enrollment_date = CURRENT_TIMESTAMP
				WHERE student_id = ? AND course_id = ?
			`).bind(userId, courseId).run();
		} else {
			// Create new enrollment with status='active'
			await env.DB.prepare(`
				INSERT INTO enrollments (student_id, course_id, status, enrollment_date, progress_percent)

/**
 * Handle POST /api/register
 */
async function handleRegister(request: Request, env: Env, corsHeaders: Record<string, string>): Promise<Response> {
	try {
		const data = await request.json() as any;

		// Validate required fields
		const requiredFields = ['firstName', 'lastName', 'username', 'email', 'password'];
		for (const field of requiredFields) {
			if (!data[field] || !data[field].trim()) {
				return new Response(
					JSON.stringify({ success: false, message: `${field} is required` }),
					{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
				);
			}
		}

		// Basic validation
		const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
		if (!emailRegex.test(data.email)) {
			return new Response(
				JSON.stringify({ success: false, message: 'Invalid email format' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		if (data.password.length < 6) {
			return new Response(
				JSON.stringify({ success: false, message: 'Password must be at least 6 characters' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		// Check if username exists
		const existingUsername = await env.DB.prepare('SELECT user_id FROM users WHERE username = ?')
			.bind(data.username)
			.first();

		if (existingUsername) {
			return new Response(
				JSON.stringify({ success: false, message: 'Username already taken' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		// Check if email exists
		const existingEmail = await env.DB.prepare('SELECT user_id FROM users WHERE email = ?')
			.bind(data.email)
			.first();

		if (existingEmail) {
			return new Response(
				JSON.stringify({ success: false, message: 'Email already registered' }),
				{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		// Hash password
		const hashedPassword = await hashPassword(data.password);

		// Insert user (set is_active to 1 for now - skip email verification)
		const result = await env.DB.prepare(`
			INSERT INTO users (
				username, email, password_hash,
				first_name, last_name, role, major_id,
				phone, is_active, created_at
			) VALUES (?, ?, ?, ?, ?, ?, ?, ?, 1, datetime('now'))
		`)
			.bind(
				data.username,
				data.email,
				hashedPassword,
				data.firstName,
				data.lastName,
				'student', // Force student role
				data.major || null,
				data.phone || null
			)
			.run();

		return new Response(
			JSON.stringify({
				success: true,
				message: 'Registration successful! You can now login.',
				userId: result.meta.last_row_id,
			}),
			{ headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	} catch (error: any) {
		console.error('Registration error:', error);
		return new Response(
			JSON.stringify({ success: false, message: 'Registration failed', error: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

/**
 * Handle GET /api/profile?user_id=X
 */
async function handleProfile(url: URL, env: Env, corsHeaders: Record<string, string>): Promise<Response> {
	const userId = url.searchParams.get('user_id');

	if (!userId) {
		return new Response(
			JSON.stringify({ success: false, message: 'user_id parameter is required' }),
			{ status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}

	try {
		// Query user data
		const user = await env.DB.prepare(`
			SELECT 
				user_id, username, email, first_name, last_name,
				role, major_id, phone, profile_image,
				created_at, last_login
			FROM users
			WHERE user_id = ?
		`)
			.bind(userId)
			.first();

		if (!user) {
			return new Response(
				JSON.stringify({ success: false, message: 'User not found' }),
				{ status: 404, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
			);
		}

		// Return user profile
		const profile = {
			userId: user.user_id,
			username: user.username,
			email: user.email,
			firstName: user.first_name,
			lastName: user.last_name,
			fullName: `${user.first_name} ${user.last_name}`,
			role: user.role,
			majorId: user.major_id,
			phone: user.phone,
			profileImage: user.profile_image,
			createdAt: user.created_at,
			lastLogin: user.last_login,
		};

		return new Response(
			JSON.stringify({
				success: true,
				message: 'Profile fetched successfully',
				user: profile,
			}),
			{ headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	} catch (error: any) {
		console.error('Profile error:', error);
		return new Response(
			JSON.stringify({ success: false, message: 'Failed to fetch profile', error: error.message }),
			{ status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
		);
	}
}

